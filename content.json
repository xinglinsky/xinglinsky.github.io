[{"title":"Window下开发环境安装教程","date":"2019-09-03T02:07:49.000Z","path":"2019/09/03/env-install/","text":"Window包管理工具Chocolatey安装一个能让你在Window下体验Linux apt/yum类似一键安装开发环境的包管理器。官网地址 https://chocolatey.org/ 安装要求 Windows 7+ / Windows Server 2003+ PowerShell v2+ (Not PowerShell Core yet though) .NET Framework 4+ (the installation will attempt to install .NET 4.0 if you do not have it installed) 使用cmd.exe安装1@\"%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \"iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\" &amp;&amp; SET \"PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\" 使用PowerShell.exe安装1Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) 运行choco查看帮助来获取更多信息，基本命令： search, install, upgrade, uninstall比如，安装svn 以管理员身份运行命令行并输入：choco search svn 1234&gt; choco search svnChocolatey v0.10.15svn 1.8.17 [Approved] Downloads cached for licensed userstortoisesvn 1.12.2.28653 [Approved] 选择安装tortoisesvn, choco install tortoisesvn -y 更新Chocolateychoco upgrade chocolatey 查看过期并更新choco outdated 12345678λ choco outdatedChocolatey v0.10.15Outdated Packages Output is package name | current version | available version | pinned?python3|3.7.3|3.7.4|falseChocolatey has determined 1 package(s) are outdated.","tags":[{"name":"环境","slug":"env","permalink":"http://xinglinsky.github.io/tags/env/"}]},{"title":"Windows安装SDK7.1","date":"2019-08-29T11:46:16.000Z","path":"2019/08/29/windows-install-sdk71/","text":"Win10安装会比较麻烦，下面会特殊说明。 卸载如果本地上有安装过VS2010的话，或者安装失败时，很有可能是因为运行库的版本问题。需要卸载相关组件。 Visual c++ 2010 x86 redistributable Visual c++ 2010 x64 redistributable（64位windows）也可以直接通过命令行来卸载（没有安装的话会提示不存在）： 12msiexec /x &#123;2F8B731A-5F2D-3EA8-8B25-C3E5E43F4BDB&#125;msiexec /x &#123;81455DEB-FC7E-3EE5-85CA-2EBDD9FD61EB&#125; Microsoft Visual C++ Compilers 2010 X86和X64版本需要在注册表中查找是否存在，路径为HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall，查找Display name为“Microsoft Visual C++ Compilers 2010 Standard-enu-x86”和“Microsoft Visual C++ Compilers 2010 Standard-enu-x64”，然后卸载。 下载、运行安装SDK7.1程序.NET 4.0下载地址如果本地已安装.NET4.0，可以不用安装。如果本机没有安装VS2010而且有编译的需求，那下载任意版本安装下。SDK7.1下载地址如果已安装.NET4.0，可能会提示.NET版本问题，直接忽略。Win10注意事项 下载操作系统对应版本的ISO文件：ISO 镜像下载说明ISO 32位下载地址ISO 64位下载地址 直接运行Setup\\SDKSetup.exe安装。 修复VS2010如果有需要的话，可以重新运行VS2010安装程序或者在控制面板-&gt;程序-&gt;VS2010右击修改，选择修复并执行。 不想在Win10下折腾的、折腾了还是失败的童鞋，可以选择直接安装VS2012或者VS2015（单独选择SDK）解决。","tags":[{"name":"C++","slug":"cplugscplus","permalink":"http://xinglinsky.github.io/tags/cplugscplus/"},{"name":"环境","slug":"env","permalink":"http://xinglinsky.github.io/tags/env/"}]},{"title":"论pyqt 编码的蹊跷——QTextStream、QString、string、unicode相关","date":"2017-01-14T06:00:00.000Z","path":"2017/01/14/encoding/","text":"环境：Pyqt4.8 32位，python2.7.3 32位你是不是每次看到什么字符编码、文件编码和字符串类型，都会有些懵逼呢？反正我有点，以前情况不复杂，这次遇到个坑，特此记录下。 背景：从qrc文件中读取某文本文件，然后解析成json，并显示在Qt控件上。该文件以utf-8编码，并保存有中文，对，就是这个中文的引出的话题,不是中文也就不复杂了…… 分析： 从rcc编译的qrc文件中读取文件，也就意味着无法使用python的标准代码： 123with open(file_path) as f: content = json.load(f) print content 别无选择，只能使用QFile。 说到QFile，自然要用到QTextStream了。 再使用python unicode()函数将str对象解码。 最后使用json库loads()方法，解析成json对象。基本代码是这样的： 1234567891011121314def read_file(path): try: f = QtCore.QFile(path) if not f.open(QtCore.QFile.ReadOnly | QtCore.QFile.Text): return \"\" ts = QtCore.QTextStream(f) tsData = ts.readAll() content = unicode(tsData, \"utf-8\", \"ignore\") return json.loads(content) except: import traceback traceback.print_exc() finally: f.close() 最后发现报错了……ValueError: Invalid control character at: line 14 column 尝试将tsData先转换为utf-8编码，结果还是报错……还尝试着直接使用str()等等方法，包括网上的一些技巧，比如：json.loads(content, strict=False)，都失败了…… 解决及总结： QTextStream在读取文本文件时，会默认使用Local的字符编码，如果不指定编码，会使后续的处理寸步难行……后续有个官方链接说明了For Python v2 the following conversions are done by default.If Qt expects a char *, signed char * or an unsigned char * (or a const version) then PyQt4 will accept a unicode or QString that contains only ASCII characters, a str, a QByteArray, or a Python object that implements the buffer protocol.If Qt expects a char, signed char or an unsigned char (or a const version) then PyQt4 will accept the same types as for char *, signed char * and unsigned char * and also require that a single character is provided.If Qt expects a QString then PyQt4 will accept a unicode, a str that contains only ASCII characters, a QChar or a QByteArray.If Qt expects a QByteArray then PyQt4 will accept a unicode that contains only Latin-1 characters, or a str Unicode()在不指定encoding参数的情况下，有两种操作。如果字符串是str对象，则会调用str()，也就是使用python默认的ascci编码来解码。如果已经是Unicode对象则不会任何附加操作。If no optional parameters are given, unicode() will mimic the behaviour of str() except that it returns Unicode strings instead of 8-bit strings. More precisely, if object is a Unicode string or subclass it will return that Unicode string without any additional decoding applied.所以在这里，我们需要指定utf-8的编码格式，才能转化为unicode对象。最后代码如下：123456789101112131415161718@contextmanagerdef read_file(path): try: f = QtCore.QFile(path) if f.open(QtCore.QFile.ReadOnly | QtCore.QFile.Text): ts = QtCore.QTextStream(f) ts.setCodec(\"utf-8\") tsData = ts.readAll() content = unicode(tsData.toUtf8(), \"utf-8\", \"ignore\") yield json.loads(content) else: yield \"\" except: import traceback traceback.print_exc() yield \"\" finally: f.close() 有个需要注意的地方，如果要gui控件能正常显示中文，content = unicode(tsData.toUtf8(), &quot;utf-8&quot;, &quot;ignore&quot;)中的toUtf8()是必不可少，不然会显示为乱码。 总结：一句话总结：区分什么是编码，什么是对象，Unicode是中转对象，str-&gt;unicode是解码，unicode-&gt;str是编码。不知在谁的blog上看到的了，很形象，很深刻……谢谢这样仁兄！ 相关链接：PyQt 4.12 Reference Guide","tags":[{"name":"编码","slug":"编码","permalink":"http://xinglinsky.github.io/tags/编码/"},{"name":"Pyqt","slug":"Pyqt","permalink":"http://xinglinsky.github.io/tags/Pyqt/"}]}]